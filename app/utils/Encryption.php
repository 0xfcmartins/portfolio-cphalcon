<?php

namespace Fcmartins\Utils;

use Exception;
use stdClass;

/**
 * Generic utils class that handles project encryption tools using php' openssl-encrypt
 *
 * @author Francisco Martins
 * @version 1.000.000, 2022-01-20 20:6
 */
class Encryption
{

    private const SC_CIPHER = "aes-256-cbc";
    private const SC_KEY = "f0d12682e15330b4ae17dad2e7e2e373";
    private const SC_ENCRYPT_JOIN = ":";

    /**
     * Encrypts a field with {@code aes-256-cbc} cipher
     *
     * @param mixed $text Field to encrypt
     * @return string Encrypted field as a {@code string} encoded with {@link base64_encode()}
     */
    static function encrypt($text): string
    {
        $iv = openssl_random_pseudo_bytes(openssl_cipher_iv_length(self::SC_CIPHER));
        $encrypted = openssl_encrypt($text, self::SC_CIPHER, self::SC_KEY, 0, $iv);
        $aggregator = base64_encode($encrypted) . self::SC_ENCRYPT_JOIN . base64_encode($iv);

        return base64_encode($aggregator);
    }

    /**
     * Decrypts a field that was previous encrypted using the {@link Encryption::encrypt()} method
     *
     * @param string $b64Aggregator The {@link Encryption::encrypt()} generates an encoded string, only a string
     * generated by that process should be used here
     * @return string Decrypted field
     */
    static function decrypt(string $b64Aggregator): string
    {
        $aggregatorParts = explode(self::SC_ENCRYPT_JOIN, base64_decode($b64Aggregator));
        $encrypted = base64_decode($aggregatorParts[0]);
        $iv = base64_decode($aggregatorParts[1]);

        return openssl_decrypt($encrypted, self::SC_CIPHER, self::SC_KEY, 0, $iv);
    }

    /**
     * Recursive method that encrypts an object attribute based on the {@code $identifier}
     *
     * @param stdClass $object Object to encrypt
     * @param string $identifier Attribute name to encrypt
     */
    static private function encryptIdentifiers(stdClass $object, string $identifier): void
    {
        if (!isset($object) || !is_object($object))
            return;

        foreach ($object as $key => $value) if (strtolower($key) == strtolower($identifier))
            $object->$key = Encryption::encrypt($value);

        foreach ($object as $attribute) {
            if (is_array($attribute) || is_object($attribute))
                Encryption::encryptIdentifiers((object)$attribute, $identifier);
        }
    }

    /**
     * Encrypts and encodes a {@link stdClass} object
     *
     * @param stdClass $object Object to encode
     * @param array $encryptTargets Object attributes to encrypt
     * @return string Encoded object
     */
    static public function encrypt_object_to_json(stdClass $object, array $encryptTargets = array("id")): string
    {
        try {
            foreach ($encryptTargets as $target)
                Encryption::encryptIdentifiers($object, $target);

            return json_encode($object);
        } catch (Exception $e) {

            return json_encode($object);
        }
    }

    /**
     * Encrypts and encodes a json {@link string} object
     *
     * @param string $jsonObject String object to encode
     * @param array $encryptTargets Object attributes to encrypt
     * @return string Encoded object
     */
    static public function encrypt_string_to_json(string $jsonObject, array $encryptTargets = array("id")): string
    {
        return Encryption::encrypt_object_to_json(json_decode($jsonObject), $encryptTargets);
    }

}